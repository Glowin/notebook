#创建对象#
虽然 Object 构造函数货对象字面量都可以用来创建单个对象，但遮掩方式有个明显的缺点：使用同一个接口创建很多对象，会禅城大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变种。

##6.2.1 工厂模式##

工厂模式是然件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程（本书后面还将讨论其他设计模式机器在 JavaScript 中的实现）。考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示。

```js
function createPerson(name, age, job) {
	var o =  new Object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function() {
		alert(this.name);
	};
	return 0;
}

var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```

函数 createPerson() 能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次的调用这个函数，而每次它都会返回一个包含三个属性的一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，有一个新模式出现了。

##6.2.2 构建函数模式##

前几章介绍过，ECMAScript 中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式江前面的例子重写如下。

```js
function Person(name, age, job) {
	this.name = name;
	this.age = age;
	this.job = job;
	this.sayName = funtion() {
	alert(this.name);
	};
}

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```

在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码除了与 createPerson() 中相同的部分外，还存在一下不同之处：
* 没有显式地创建对象；
* 直接将属性和方法赋给了 this 对象；
* 没有 return 语句。

此外，还应该注意到函数名 Person 使用的是大写字母_P_。按照管惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他OO预言，主要是为了区别与 ECMAScript 中的其他函数；应为构造函数本身也是函数，只不过可以用来创建对象而已。

要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历一下4个步骤：
1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（喂这个新对象添加属性）；
4. 返回新对象。

在前面的例子的最后，person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor （构造函数）属性，改属性指向 Person，如下所示。

```js
alert(person1.constructor == Person); //true
alert(person2.constructor == Person); //true
```

对象的 constructor 属性最初是用来表示对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。wmf在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证。

```js
alert(person1 instanceof Object);   //ture
alert(person1 instanceof Person);   //ture
alert(person2 instanceof Object);   //ture
alert(person2 instanceof Person);   //ture
```

创建自定义的构造函数意味着将来可以将它的实例标识喂一种特定的类型；而这正式构造函数模式胜过工厂模式的地方。在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为所有对象均继承自 Object （详细内容稍后讨论）。

>以这种方式定义的构造函数是定义在 Global 对象（在浏览器中是 window 对象）中的。第8章将详细讨论浏览器对象模型（BOM）。





















